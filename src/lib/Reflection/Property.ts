/* Copyright 2016 Ling Zhang

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License. */

import { Method } from './Method';
import { AgentFeatures } from './AgentFeatures';
import { Member } from './Member';
import { Type } from './Type';

/**
 * Property
 */
export class Property extends Member<Type> {
  private _hasInitializers: boolean;
  private _hasInterceptors: boolean;

  constructor(parent: Type, private _key: PropertyKey, private _descriptor?: PropertyDescriptor) {
    super(parent);
  }

  get value(): Method<Property> {
    let maxFunctionParameters = 0,
      _descriptor = this._descriptor; // field don't have parameter
    if (_descriptor && _descriptor.value && 'function' === typeof _descriptor.value) {
      maxFunctionParameters = _descriptor.value.length;
    }
    const value = new Method(this, maxFunctionParameters);
    Reflect.defineProperty(this, 'value', { value });
    return value;
  }

  get setter(): Method<Property> {
    const value = new Method(this, 1);
    Reflect.defineProperty(this, 'setter', { value });
    return value;
  }

  get getter(): Method<Property> {
    const value = new Method(this, 0);
    Reflect.defineProperty(this, 'getter', { value });
    return value;
  }

  hasInitializers(): boolean {
    if (this._hasInitializers == null) {
      this._hasInitializers = this.hasInitializer() || this.setter.hasInitializer() || this.value.hasInitializer();
    }
    return this._hasInitializers;
  }

  hasInterceptors(): boolean {
    if (this._hasInterceptors == null) {
      this._hasInterceptors =
        this.hasInterceptor() ||
        this.getter.hasInterceptor() ||
        this.value.hasInterceptor() ||
        this.value.hasParameters();
    }
    return this._hasInterceptors;
  }

  hasFeatures(features: AgentFeatures): boolean {
    if (this._hasInitializers && this._hasInterceptors) {
      return features > 1;
    }
    switch (features) {
      case AgentFeatures.Metadata:
        return this.hasMetadata();
      case AgentFeatures.Initializer:
        return this.hasInitializers();
      case AgentFeatures.Interceptor:
        return this.hasInterceptors();
      case AgentFeatures.Altered:
        return this.hasInitializers() || this.hasInterceptors();
      default:
        return false;
    }
  }

  get type(): any {
    return this.getMetadata('design:type');
  }

  get paramtypes(): Array<any> {
    return this.getMetadata('design:paramtypes');
  }

  get returntype(): any {
    return this.getMetadata('design:returntype');
  }

  get targetKey(): PropertyKey {
    return this._key;
  }

  get descriptor(): PropertyDescriptor | undefined {
    return this._descriptor;
  }

  /**
   * Add the metadata generated by tsc
   * @param {string} key
   * @param value
   */
  addMetadata(key: string, value: any): void {
    super.addMetadata(key, value);

    // apply method parameter type into parameter metadata
    if (this._descriptor) {
      if (this._descriptor.value) {
        // this is a method
        if (key === 'design:paramtypes' && value && value.length) {
          this.value.addMetadata('design:paramtypes', value);
          const types = value as Array<any>;
          for (let idx = types.length - 1; idx >= 0; idx--) {
            this.value.parameter(idx).addMetadata('design:type', types[idx]);
          }
        } else if (key === 'design:returntype') {
          this.value.addMetadata('design:returntype', value);
        }
      }

      if (this._descriptor.get) {
        if (key === 'design:type') {
          this.getter.addMetadata('design:returntype', value);
        }
      }

      if (this._descriptor.set) {
        if (key === 'design:paramtypes' && value && value.length) {
          this.setter.addMetadata('design:paramtypes', value);
          const types = value as Array<any>;
          for (let idx = types.length - 1; idx >= 0; idx--) {
            this.setter.parameter(idx).addMetadata('design:type', types[idx]);
          }
        }
      }
    } else {
      // this is field
      this.value.addMetadata(key, value);
    }
  }
}
