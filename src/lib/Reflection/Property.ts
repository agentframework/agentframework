import { Method } from './Method';
import { AgentFeatures, hasFeature } from './AgentFeatures';
import { Member } from './Member';

/**
 * Property
 */
export class Property<P> extends Member<P> {
  protected readonly parent: P;
  private _hasInitializers: boolean;
  private _hasInterceptors: boolean;

  constructor(parent: P, private _key: PropertyKey, private _descriptor?: PropertyDescriptor) {
    super(parent);
  }

  get value(): Method<Property<P>> {
    let maxFunctionParameters = 0,
      _descriptor = this._descriptor; // field don't have parameter
    if (_descriptor && _descriptor.value && 'function' === typeof _descriptor.value) {
      maxFunctionParameters = _descriptor.value.length;
    }
    const value = new Method(this, maxFunctionParameters);
    Reflect.defineProperty(this, 'value', { value });
    return value;
  }

  get setter(): Method<Property<P>> {
    const value = new Method(this, 1);
    Reflect.defineProperty(this, 'setter', { value });
    return value;
  }

  get getter(): Method<Property<P>> {
    const value = new Method(this, 0);
    Reflect.defineProperty(this, 'getter', { value });
    return value;
  }

  hasFeatures(features: AgentFeatures): boolean {
    let results;

    if (this._hasInitializers && this._hasInterceptors) {
      return features !== 0;
    }

    if (hasFeature(features, AgentFeatures.Initializer)) {
      // improve half performance here
      // cache true result, only need calculate for false condition
      if (this._hasInitializers) {
        return true;
      } else {
        this._hasInitializers = this.hasInitializer() || this.setter.hasInitializer() || this.value.hasInitializer();
        if (features === 3) {
          results = this._hasInitializers;
        } else {
          return this._hasInitializers;
        }
      }
    }

    if (hasFeature(features, AgentFeatures.Interceptor)) {
      // improve half performance here
      // cache true result, only need calculate for false condition
      if (this._hasInterceptors) {
        return true;
      } else {
        this._hasInterceptors =
          this.hasInterceptor() ||
          this.getter.hasInterceptor() ||
          this.value.hasInterceptor() ||
          this.value.hasParameterInterceptor() ||
          this.value.hasParameterInitializer();

        if (features === 3) {
          results = results && this._hasInterceptors;
        } else {
          return this._hasInterceptors;
        }
      }
    }

    return results || false;
  }

  get type(): any {
    return this.getMetadata('design:type');
  }

  get paramtypes(): Array<any> {
    return this.getMetadata('design:paramtypes');
  }

  get returntype(): any {
    return this.getMetadata('design:returntype');
  }

  get targetKey(): PropertyKey {
    return this._key;
  }

  get descriptor(): PropertyDescriptor | undefined {
    return this._descriptor;
  }

  /**
   * Add the metadata generated by tsc
   * @param {string} key
   * @param value
   */
  addMetadata(key: string, value: any): void {
    super.addMetadata(key, value);

    // apply method parameter type into parameter metadata
    if (this._descriptor) {
      if (this._descriptor.value) {
        // this is a method
        if (key === 'design:paramtypes' && value && value.length) {
          this.value.addMetadata('design:paramtypes', value);
          const types = value as Array<any>;
          for (let idx = types.length - 1; idx >= 0; idx--) {
            this.value.parameter(idx).addMetadata('design:type', types[idx]);
          }
        } else if (key === 'design:returntype') {
          this.value.addMetadata('design:returntype', value);
        }
      }

      if (this._descriptor.get) {
        if (key === 'design:type') {
          this.getter.addMetadata('design:returntype', value);
        }
      }

      if (this._descriptor.set) {
        if (key === 'design:paramtypes' && value && value.length) {
          this.setter.addMetadata('design:paramtypes', value);
          const types = value as Array<any>;
          for (let idx = types.length - 1; idx >= 0; idx--) {
            this.setter.parameter(idx).addMetadata('design:type', types[idx]);
          }
        }
      }
    } else {
      // this is field
      if (key === 'design:type' && value) {
        const types = value as Array<any>;
        this.value.addMetadata('design:returntype', types[0]);
      }
    }
  }
}
