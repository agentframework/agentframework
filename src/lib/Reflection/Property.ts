import { Method } from './Method';
import { AgentFeatures } from './AgentFeatures';
import { Member } from './Member';
import { Type } from './Type';

/**
 * Property
 */
export class Property extends Member<Type> {
  private _hasInitializers: boolean;
  private _hasInterceptors: boolean;

  constructor(parent: Type, private _key: PropertyKey, private _descriptor?: PropertyDescriptor) {
    super(parent);
  }

  get value(): Method<Property> {
    let maxFunctionParameters = 0,
      _descriptor = this._descriptor; // field don't have parameter
    if (_descriptor && _descriptor.value && 'function' === typeof _descriptor.value) {
      maxFunctionParameters = _descriptor.value.length;
    }
    const value = new Method(this, maxFunctionParameters);
    Reflect.defineProperty(this, 'value', { value });
    return value;
  }

  get setter(): Method<Property> {
    const value = new Method(this, 1);
    Reflect.defineProperty(this, 'setter', { value });
    return value;
  }

  get getter(): Method<Property> {
    const value = new Method(this, 0);
    Reflect.defineProperty(this, 'getter', { value });
    return value;
  }

  hasInitializers(): boolean {
    if (this._hasInitializers !== undefined) {
      return this._hasInitializers;
    }
    this._hasInitializers = this.hasInitializer() || this.setter.hasInitializer() || this.value.hasInitializer();
    return this._hasInitializers;
  }

  hasInterceptors(): boolean {
    if (this._hasInterceptors !== undefined) {
      return this._hasInterceptors;
    }
    this._hasInterceptors =
      this.hasInterceptor() ||
      this.getter.hasInterceptor() ||
      this.value.hasInterceptor() ||
      this.value.hasParameterInterceptor() ||
      this.value.hasParameterInitializer();
    return this._hasInterceptors;
  }

  hasFeatures(features: AgentFeatures): boolean {
    if (this._hasInitializers && this._hasInterceptors) {
      return features !== 0;
    }
    if (AgentFeatures.Initializer === features) {
      return this.hasInitializers();
    } else if (AgentFeatures.Interceptor === features) {
      return this.hasInterceptors();
    } else if (features === 3) {
      return this.hasInitializers() && this.hasInterceptors();
    }
    return this.hasAttribute();
  }

  get type(): any {
    return this.getMetadata('design:type');
  }

  get paramtypes(): Array<any> {
    return this.getMetadata('design:paramtypes');
  }

  get returntype(): any {
    return this.getMetadata('design:returntype');
  }

  get targetKey(): PropertyKey {
    return this._key;
  }

  get descriptor(): PropertyDescriptor | undefined {
    return this._descriptor;
  }

  /**
   * Add the metadata generated by tsc
   * @param {string} key
   * @param value
   */
  addMetadata(key: string, value: any): void {
    super.addMetadata(key, value);

    // apply method parameter type into parameter metadata
    if (this._descriptor) {
      if (this._descriptor.value) {
        // this is a method
        if (key === 'design:paramtypes' && value && value.length) {
          this.value.addMetadata('design:paramtypes', value);
          const types = value as Array<any>;
          for (let idx = types.length - 1; idx >= 0; idx--) {
            this.value.parameter(idx).addMetadata('design:type', types[idx]);
          }
        } else if (key === 'design:returntype') {
          this.value.addMetadata('design:returntype', value);
        }
      }

      if (this._descriptor.get) {
        if (key === 'design:type') {
          this.getter.addMetadata('design:returntype', value);
        }
      }

      if (this._descriptor.set) {
        if (key === 'design:paramtypes' && value && value.length) {
          this.setter.addMetadata('design:paramtypes', value);
          const types = value as Array<any>;
          for (let idx = types.length - 1; idx >= 0; idx--) {
            this.setter.parameter(idx).addMetadata('design:type', types[idx]);
          }
        }
      }
    } else {
      // this is field
      this.value.addMetadata(key, value);
    }
  }
}
