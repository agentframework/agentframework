import { Attribute } from '../Attribute';
import { AgentTypeInvocation } from './Invocation/AgentTypeInvocation';
import { ClassTypeInvocation } from './Invocation/ClassTypeInvocation';
import { OnDemandInterceptorFactory } from './OnDemandInterceptorFactory';
import { TypeInvocation } from '../TypeInvocations';
import { PropertyInfo } from '../Reflection/PropertyInfo';
import { Invocation } from '../Invocation';
import { TypeInfo } from '../Reflection/TypeInfo';
import { OnDemandParameterInterceptor } from './Interceptor/OnDemandParameterInterceptor';
import { ClassConstructorState } from '../Knowledges/ClassConstructors';
import { GetterSetterInvocation } from './Invocation/GetterSetterInvocation';
import { MethodInvocation } from './Invocation/MethodInvocation';
import { CONSTRUCTOR } from '../WellKnown';

export class OnDemandInvocationFactory {
  /**
   * this function output is NOT cached
   * the type generated by this chain is been CACHED by domain
   *
   * @internal
   */
  static createAgentInvocation(target: Function, attribute: Attribute): TypeInvocation {
    const invocation = new AgentTypeInvocation(target);
    const design = invocation.design.property(CONSTRUCTOR);
    let chain: Invocation<TypeInfo> = invocation;
    if (design.version) {
      chain = OnDemandInterceptorFactory.addInterceptors(chain, design.ownInterceptors);
    }
    chain = OnDemandInterceptorFactory.addInterceptor(chain, attribute);
    return chain;
  }

  /**s
   * this chain is been cached by caller
   *
   * @internal
   */
  static createConstructorInvocation(target: Function): ClassConstructorState {
    const invocation = new ClassTypeInvocation(target);
    const design = invocation.design.property(CONSTRUCTOR);
    let chain: Invocation<TypeInfo> = invocation;
    if (design.version) {
      if (design.hasParameter()) {
        chain = OnDemandInterceptorFactory.addInterceptor(chain, new OnDemandParameterInterceptor(design));
      }
      chain = OnDemandInterceptorFactory.addInterceptors(chain, design.ownInterceptors);
    }
    return { invocation: chain, version: design.version, design: design };
  }

  /**
   * @internal
   */
  static createFieldInvocation<T extends PropertyInfo>(property: T, cache: WeakMap<any, any>): Invocation<T> {
    let chain: Invocation<T> = new GetterSetterInvocation(property, cache);
    return OnDemandInterceptorFactory.addInterceptors<T>(chain, property.ownInterceptors);
  }

  /**
   * @internal
   */
  static createPropertyInvocation<T extends PropertyInfo>(method: Function, property: T): Invocation<T> {
    let chain: Invocation<T> = new MethodInvocation(method, property);
    if (property.hasParameter()) {
      chain = OnDemandInterceptorFactory.addInterceptor(chain, new OnDemandParameterInterceptor(property));
    }
    return OnDemandInterceptorFactory.addInterceptors(chain, property.ownInterceptors);
  }
}
