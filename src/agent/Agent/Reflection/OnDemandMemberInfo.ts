/* Copyright 2016 Ling Zhang

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License. */

import { Annotation } from '../../../dependencies/core';
import { Attribute } from '../Attribute';
import { MemberInfo } from './MemberInfo';
import { Filter } from './Filter';
import { Class } from '../Arguments';
import { HasInterceptor } from '../CustomInterceptor';
import { Once } from '../Decorators/Once/Once';

// import { cache } from '../Helpers/Cache';
// let a = 0;

/**
 * Access and store attribute and metadata for reflection
 */
export abstract class OnDemandMemberInfo<A extends Annotation = Annotation> implements MemberInfo {
  /**
   * to improve performance
   */
  private interceptorsVersion: number | undefined;
  private interceptors: Array<object> = [];

  /**
   * create member
   */
  constructor(readonly target: object | Function, readonly key: string | symbol) {}

  /**
   * Get name implementation, can be override by divided class
   */
  protected abstract getName(): string;

  /**
   * Get name
   */
  get name(): string {
    return Once(this, 'name', this.getName());
  }

  /**
   * Get declaring type implementation, can be override by divided class
   */
  protected getDeclaringType(): Function {
    if ('object' === typeof this.target) {
      return this.target.constructor;
    } else {
      return this.target;
    }
  }

  /**
   * Get declaring type
   */
  get declaringType(): Function {
    return Once(this, 'declaringType', this.getDeclaringType());
  }

  /**
   * Get member kind implementation, can be override by divided class
   */
  protected abstract getKind(): number;

  /**
   * Get member kind
   */
  get kind(): number {
    return Once(this, 'kind', this.getKind());
  }

  /**
   * Get metadata object implementation, can be override by divided class
   */
  protected abstract getAnnotation(): A | undefined;

  /**
   * Get metadata object, undefined if not annotated.
   */
  get annotation(): A | undefined {
    return Once(this, 'annotation', this.getAnnotation());
  }

  /**
   * version. 0 means not annotated
   */
  get version(): number {
    const annotation = this.annotation;
    return annotation ? annotation.version : 0;
  }

  /**
   * Get type implementation, can be override by divided class
   */
  protected abstract getType(): Function | undefined;

  /**
   * Get type
   */
  get type(): Function | undefined {
    return Once(this, 'type', this.getType());
  }

  /**
   * get attributes
   */
  protected getAttributes(): ReadonlyArray<object> | undefined {
    const annotation = this.annotation;
    if (annotation && annotation.attributes.length) {
      return annotation.attributes;
    }
    return;
  }

  /**
   * Add an attribute
   *
   * @param {Attribute} attribute
   */
  abstract addAttribute<A4 extends Attribute>(attribute: A4): void;

  // /**
  //  * Add the metadata generated by tsc
  //  *
  //  * @param {string} key
  //  * @param value
  //  */
  // addMetadata(key: string, value: any): void {
  //   Annotator.addMetadata(this.annotation, key, value);
  // }

  /**
   * Return true if this type contains a giving attribute, otherwise false.
   *
   * @param type
   * @returns {boolean}
   */
  hasOwnAttribute<A1 extends Attribute>(type?: Class<A1>): boolean {
    const attributes = this.getAttributes();
    if (attributes) {
      if (type) {
        return attributes.some((a) => a instanceof type);
      } else {
        return true;
      }
    }
    return false;
  }

  /**
   * Get specified attribute
   */
  getOwnAttribute<A2 extends Attribute>(type: Class<A2>): A2 | undefined {
    const attributes = this.getAttributes();
    if (attributes) {
      const results = attributes.filter((a) => a instanceof type);
      return <A2>results[0];
    }
    return;
  }

  /**
   * Return an array of attributes which is instance of giving type
   *
   * @returns {Array<Attribute>}
   */
  getOwnAttributes<A3 extends Attribute>(type?: Class<A3>): ReadonlyArray<A3> {
    const attributes = this.getAttributes();
    if (attributes) {
      if (type) {
        return attributes.filter((a) => a instanceof type) as Array<A3>;
      } else {
        return <A3[]>attributes.slice(0);
      }
    }
    return [];
  }

  /**
   * Return an array of all the attributes which provide getter interceptor
   *
   * @returns {Array<Attribute>}
   */
  findOwnAttributes<A5 extends Attribute>(filter: Filter<Attribute>, filterCriteria?: any): ReadonlyArray<A5> {
    const attributes = this.getAttributes();
    if (attributes) {
      return attributes.filter((a) => filter(a, filterCriteria)) as Array<A5>;
    }
    return [];
  }

  /**
   * Return true if any of the attribute provide getInterceptor method
   *
   * @returns {boolean}
   */
  hasOwnInterceptor(): boolean {
    const attributes = this.getAttributes();
    if (attributes) {
      if (this.version !== this.interceptorsVersion) {
        this.interceptors = attributes.filter(HasInterceptor);
        this.interceptorsVersion = this.version;
      }
      return this.interceptors.length > 0;
    }
    return false;
  }

  /**
   * Return an array of all the attributes which provide getter interceptor
   *
   * @returns {Array<Attribute>}
   */
  getOwnInterceptors(): ReadonlyArray<object> {
    const attributes = this.getAttributes();
    if (attributes) {
      if (this.version !== this.interceptorsVersion) {
        this.interceptors = attributes.filter(HasInterceptor);
        this.interceptorsVersion = this.version;
      }
      return this.interceptors;
    }
    return [];
  }

  /**
   * Read the metadata generated by tsc
   *
   * @param key
   */
  protected getOwnMetadata(key: string): any | undefined {
    // if (this.annotated) {
    const annotation = this.annotation;
    if (annotation && annotation.has(key)) {
      return annotation.get(key);
    }
    // }
    /* istanbul ignore next */
    if (Reflect['getOwnMetadata']) {
      return Reflect['getOwnMetadata'](key, this.declaringType.prototype, this.key);
    }
    return;
  }
}
